---
title: "Control Structures and Functions in R"
author: "Eric KWIZERA"
date: "2025-10-16"
output:html_document:
    
---

## Control structures

# Grouping

Control structures in R allow you to control the flow of execution of a series of R
expressions. Basically, control structures allow you to put some “logic” into your R
code, rather than just always executing the same R code every time. Control
structures allow you to respond to inputs or to features of the data and execute
different R expressions accordingly. Commonly used control structures are • if and
else: testing a condition and acting on it • for: execute a loop a fixed number of times
• while: execute a loop while a condition is true • repeat: execute an infinite loop
(must break out of it to stop) • break: break the execution of a loop • next: skip an
interaction of a loop


if (condition){ ## do something } ## continue with the rest of the code. if( condition){ do something
} else { do something else
}
You can also create a series of test by following the initial if with a number of elseifsif(condition){ do something
}else if (condition 2){ Do something different }else{ do something different }

## Function on R
```{r}
f<-function(x) x^2
formals(f)
body(f)
environment(f)


```

#ifelse(test,yes,No)
```{r}
pvalues<-c(.867,0.0054,0.0018,0.1572,0.0183,0.5386)
results<-ifelse(pvalues<0.05,"Significant"," Not significant")
results

```


```{r}
x<-runif(1,0,10)
if(x>3){
y<-10
}else {
y<-0
}
```

# The value of y is a set depending on whether x>3 or not. This can also be achieved
```{r}
y<-if (x>3){
10
}else {
0

}
```

## For
```{r}
for(i in 1:10){
print(i)
}
x<-c("a","b","c","d")
x[3]

for(i in 1:5){
print(x[i])
}

for(i in 1:5)print(1:i)
for(i in 5:1)print(1:i)
```
## while Loops
It begins by testing a condition, if it is true, then they execute the loop body. once the loop body is executed,the condition is tested again, until the condition is false. after
which the loop exits.

```{r}
count<-1
while (count<10){
print(count)
count<-count+1
}

z<-5
set.seed(1)
while(z>= 3 && z<=10){
coin<-rbinom(1,1,0.5)
if (coin==1){
z=z+1
} else {
  z<-z-1
}
}
print(z)

```

# next, break
This is used to skip an iteration of a loop


```{r}
for (i in 1:100){
print(1:i)
if (i>20){
  break
}
}

```

## Function
functionname<-function(parameters){ statements return(value) }
f1<-function(x){ result<-x^2+2 return(result) }
f2<-function(x,y){ result<-x
2+y2-4 return(result) }
```{r}
f<-function(x,y){
result<-x+(2*y)+3
return(result)
}
f(2,3)
f(2,3)
```

You can use args() function to view the parameter names and default values
##Exercises
Make functions that calculate summary statistics
Make a function to calculate two sample t test
# Applying functions to matrices and data frame. a<-4

```{r}
a<-4
sqrt(4)
b<- c(1,243,5.754,2.987)
round(b)
c<-matrix(runif(12),nrow=3)
c
log(c)
mean(c)

```

Notice that the mean of matrix c results in a scalar (0.444). the mean() take the
average of all 12 elements in the matrix.But what if you want the three rowmeans
or the four column means?
R provides a function, apply() that allows to apply an arbitrary function to any
dimension of a matrix, array or data frame. The format for the apply() functionis -
apply(x, MARGIN, FUN,…) where x stands for the data object, Margin can be 1(rows)
and 2(columns ) ## Col/Row Sums and Means • rowSums = apply(x, 1, sum) • rowMeans = apply(x, 1, mean) • colSums = apply(x, 2, sum) • colMeans = apply(x, 2, mean)

## lappy function
lapply() takes three inputs:,x,a list,a function, and…, It applies to each element of thelist and returns a new list. lapply(x,f,…). It is called function because it takes functionas an argument. Assume we have a data frame df. instead of assigning the result pf
lappliy() to df, we will assign them to df[] to ensure we get a data frame


```{r}
fix_missing<-function(x){
x[x==-99]<-NA
x
}
function1<-function(x){
x^2
}
curve(function1,-4,4)

#df[]<-lappy(df,fix_missing)
```

It works for any number of columns.There is no way to accidentally miss a column
There is no way to accidentally treat one column differently than another
It easy to generalize this technique to a subset of columns.

```{r}
#df[1:5]<- lapply(df[1:5],fix_missing )
```
## sapply
sapply() and vapply(), variants of lapply() that produces vectors,matrices, andarrays as Output, instead of lists map(), and mapply which iterate over multiple
input data structures in parallel
Another important function when dealing with big data is split() -tapply
# Titanic data
```{r}
str(Titanic)
View(Titanic)
apply(Titanic,c(1,2),sum )

options(digits = 2)
apply(Titanic,c(1,2),sum)[3:4,]
apply(Titanic,c(1,4),sum)[3:4,]
apply(Titanic,c(1,2,4),sum)
#apply(Titanic,c(1,2,4),sum)[3:4,]
apply(Titanic,c(1,2,4),sum)[3:4,,]
ftable(apply(Titanic,c(1,4,2),sum)[3:4,,])
ftable(apply(Titanic,c(1,4,2),sum)[3:4,,])[1:2,]
ftable(apply(Titanic,c(1,4,2),sum)[3:4,,])[3:4,]
digit=2
prop.table(ftable(apply(Titanic,c(1,4,2),sum)[3:4,,])[1:2,], margin =2)
prop.table(ftable(apply(Titanic,c(1,4,2),sum)[3:4,,])[3:4,], margin =2)
matrix(prop.table(ftable(apply(Titanic,c(1,4,2),sum)[3:4,,])[1:2,], margin = 2),nrow = 2, dimnames = list(dimnames(Titanic)$Survived,dimnames(Titanic)$Sex))
matrix(prop.table(ftable(apply(Titanic,c(1,4,2),sum)[3:4,,])[3:4,], margin = 2),nrow = 2, dimnames = list(dimnames(Titanic)$Survived,dimnames(Titanic)$Sex))
### Create dataset
Student<-c("John ncuti", "Angela bakame", "Bruce wizeye","Alexis aganze", "claude Rukundo", "Joel Kagabo", "Mary ineza")
Math<-c(600,412,358,495,512,410,522)
Science<-c(95,99,80,82,75,89,77)
English<-c(25,22,18,20,29,30,27)
roster<-data.frame(Student,Math,Science,English,stringsAsFactors = FALSE)
### standardize variables and obtains the performance scores becausethey are reported on different scale( With widely differing means and standard deviations, we need to make them comparable before we combine them.)
z<-scale(roster[,2:4])
### performance of each students using rowmeans and adding them to roster using cbind()
score<-apply(z,1,mean)
roster<-cbind(roster,score)
### Grades the students: quantile function gives the percentile rankof each student's performance score check the cutoff of A
y<-quantile(score,c(.8,.6,.4,.2))
## create a grade variable us
roster$grade[score>=y[1]]<-"A"
roster$grade[score<y[1]&score>=y[2]]<-"B"
roster$grade[score<y[2]& score>=y[3]]<-"C"
roster$grade[score<y[3]& score>=y[4]]<-"D"
roster$grade[score<y[4]]<-"F"
#### Dealing with names
name<-strsplit((roster$Student),"")
lastname<-sapply (name,"[",2)
firstname<-sapply(name,"[",1)
roster<-cbind(firstname, lastname,roster[,-1])
roster<-roster[order(lastname,firstname),]
roster
```

## Aggregation and reshaping
# transpose

```{r}
cars<-mtcars[1:5, 1:4]
cars
t(cars)
```
# aggregate data
aggregate() collapse data in R using one or more by variables and a defined function

```{r}
options(digits=3)
attach(mtcars)
aggdata<-aggregate(mtcars,by=list(cyl,gear),FUN=mean,na.rm=TRUE)
```

# Reshape
Step 1: install the package reshape2 step 2: melt data step 3: Cast the melted datainto any shape you desire
During the cast, you can aggregate the data with any function you wish. 

```{r}
id<-c(1,1,2,2)
time<-c(1,2,1,2)
x1<-c(5,3,6,2)
x2<-c(6,5,1,4)
mydata<-data.frame(id,time,x1,x2)

```